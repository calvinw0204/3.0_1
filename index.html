<!doctype html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>AR 互動牆（含相片 & 塗鴉）</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden}
    #overlayUI {
      position: fixed; left: 0; right: 0; bottom: 0; z-index: 30;
      display:flex; gap:8px; padding:10px; align-items:center;
      background: rgba(10,10,12,0.45); backdrop-filter: blur(6px);
    }
    #overlayUI input[type="text"]{
      flex:1;padding:10px;border-radius:8px;border:1px solid #444;font-size:16px;
      background: rgba(255,255,255,0.95);
    }
    #overlayUI button{padding:10px 12px;border-radius:8px;border:0;cursor:pointer}
    .btn-primary{background:#4ade80}
    .btn-ghost{background:#f3f4f6}
    #topHint{
      position: fixed; left:12px; right:12px; top:12px; z-index:30;
      color:#fff;background:rgba(0,0,0,0.45);padding:10px;border-radius:8px;
    }

    /* 畫板 full-screen */
    #drawLayer {
      position: fixed; inset:0; z-index: 60; display:none;
      background: rgba(0,0,0,0.4);
    }
    #drawCanvas { touch-action: none; background: #fff; border-radius: 8px; display:block; margin: 40px auto; box-shadow:0 8px 30px rgba(0,0,0,0.5)}
    #drawControls { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); z-index: 70; display:flex; gap:8px; }
  </style>
</head>
<body>
  <div id="topHint">👆 進入 AR 後輕觸地面放置留言牆。可上載相片或用塗鴉創作，會貼到牆上。</div>

  <!-- UI -->
  <div id="overlayUI">
    <input id="textInput" type="text" placeholder="輸入留言 (最多 120 字)"/>
    <button id="addText" class="btn-primary">加到牆</button>
    <button id="uploadPhoto" class="btn-ghost">上載相片</button>
    <button id="openDraw" class="btn-ghost">塗鴉</button>
    <button id="clearWall" class="btn-ghost">清牆</button>
  </div>

  <!-- 隱藏 file input (拍相 / 選圖用) -->
  <input id="fileInput" type="file" accept="image/*" style="display:none" capture="environment">

  <!-- Draw layer -->
  <div id="drawLayer">
    <canvas id="drawCanvas" width="800" height="600"></canvas>
    <div id="drawControls">
      <button id="drawClear" class="btn-ghost">清畫</button>
      <button id="drawUndo" class="btn-ghost">復原</button>
      <button id="drawSave" class="btn-primary">儲存並貼到牆</button>
      <button id="drawClose" class="btn-ghost">取消</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';

    // ---------- THREE / WebXR 基本場景 ----------
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 20);
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
    scene.add(light);

    // 留言牆的 canvas texture（用來繪製文字/圖像/塗鴉）
    const wallCanvas = document.createElement('canvas');
    wallCanvas.width = 1024; wallCanvas.height = 1024;
    const wctx = wallCanvas.getContext('2d');

    const wallTexture = new THREE.CanvasTexture(wallCanvas);
    wallTexture.encoding = THREE.sRGBEncoding;
    wallTexture.needsUpdate = true;

    // wall mesh (plane)
    const wallW = 1.2, wallH = 0.8;
    const wallGeo = new THREE.PlaneGeometry(wallW, wallH);
    const wallMat = new THREE.MeshBasicMaterial({ map: wallTexture, transparent:true });
    const wallMesh = new THREE.Mesh(wallGeo, wallMat);
    wallMesh.visible = false;
    scene.add(wallMesh);

    // 初始資料容器（messages: 文字陣列；images: 圖像物件陣列）
    const messages = []; // 文字
    const images = [];   // { img: Image, w,h }

    // render wall: 會把 messages 與 images 畫到 wallCanvas 上
    function renderWall(){
      // 清空
      wctx.clearRect(0,0,wallCanvas.width, wallCanvas.height);
      // 背景
      wctx.fillStyle = 'rgba(18,18,20,0.7)';
      wctx.fillRect(0,0,wallCanvas.width, wallCanvas.height);
      // 標題
      wctx.fillStyle = '#fff';
      wctx.font = 'bold 44px system-ui';
      wctx.fillText('AR 留言牆', 40, 80);

      // draw images first (排版：左邊為圖，右邊為文字)
      const pad = 24;
      const imgAreaW = 420;
      let imgY = 120;
      for (let i = 0; i < images.length; i++) {
        const it = images[i];
        // scale to fit imgAreaW
        const scale = Math.min(imgAreaW / it.w, 160 / it.h, 1);
        const dw = it.w * scale;
        const dh = it.h * scale;
        wctx.drawImage(it.img, pad, imgY, dw, dh);
        imgY += dh + 12;
        if (imgY > wallCanvas.height - 200) break;
      }

      // draw messages on the right side
      const textX = imgAreaW + pad*2;
      let y = wallCanvas.height - 40;
      const lineH = 40;
      wctx.textAlign = 'left';
      wctx.fillStyle = 'rgba(255,255,255,0.95)';
      wctx.font = '600 32px system-ui';
      for (let i = messages.length - 1; i >= 0; i--) {
        const text = '• ' + messages[i];
        y -= lineH;
        wrapText(wctx, text, textX, y, wallCanvas.width - textX - pad, 34);
        if (y < 120) break;
      }

      wallTexture.needsUpdate = true;
    }

    function wrapText(ctx, text, x, y, maxWidth, lineHeight){
      const words = text.split(' ');
      let line = '', curY = y;
      for (let n=0;n<words.length;n++){
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && n > 0){
          ctx.fillText(line, x, curY);
          line = words[n] + ' ';
          curY += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, curY);
    }

    // draw initial
    renderWall();

    // reticle (放置提示)
    const rGeo = new THREE.RingGeometry(0.06,0.075,32);
    const rMat = new THREE.MeshBasicMaterial({ color:0x66ffcc, side:THREE.DoubleSide });
    const reticle = new THREE.Mesh(rGeo, rMat);
    reticle.rotation.x = -Math.PI / 2;
    reticle.visible = false;
    scene.add(reticle);

    // ARButton
    const arButton = ARButton.createButton(renderer, {
      requiredFeatures: ['hit-test','dom-overlay'],
      domOverlay: { root: document.body }
    });
    document.body.appendChild(arButton);

    let hitTestSource = null, hitTestSourceRequested = false;
    renderer.xr.addEventListener('sessionstart', () => {
      hitTestSourceRequested = false;
      reticle.visible = false;
      wallMesh.visible = false;
    });

    renderer.xr.addEventListener('sessionend', () => {
      hitTestSourceRequested = false;
      reticle.visible = false;
    });

    // controller select 放置牆
    const controller = renderer.xr.getController(0);
    controller.addEventListener('select', () => {
      if (reticle.visible) {
        wallMesh.position.setFromMatrixPosition(reticle.matrix);
        // 朝向鏡頭
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        const yaw = Math.atan2(camDir.x, camDir.z);
        wallMesh.rotation.set(0, yaw + Math.PI, 0);
        wallMesh.visible = true;
      }
    });
    scene.add(controller);

    // XR 逐幀
    function onXRFrame(time, frame){
      const session = renderer.xr.getSession();
      if (session && frame){
        if (!hitTestSourceRequested){
          session.requestReferenceSpace('viewer').then((refSpace) => {
            session.requestHitTestSource({ space: refSpace }).then((source) => {
              hitTestSource = source;
            });
          });
          hitTestSourceRequested = true;
        }
        const refSpace = renderer.xr.getReferenceSpace();
        if (hitTestSource){
          const hits = frame.getHitTestResults(hitTestSource);
          if (hits.length){
            const hit = hits[0];
            const pose = hit.getPose(refSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }
      renderer.render(scene, camera);
    }
    renderer.setAnimationLoop(onXRFrame);

    // -------- UI Interactions (Text / Photo / Draw) --------
    const textInput = document.getElementById('textInput');
    const addTextBtn = document.getElementById('addText');
    const uploadPhotoBtn = document.getElementById('uploadPhoto');
    const fileInput = document.getElementById('fileInput');
    const openDrawBtn = document.getElementById('openDraw');
    const clearWallBtn = document.getElementById('clearWall');

    addTextBtn.addEventListener('click', () => {
      const v = (textInput.value||'').trim();
      if (!v) return;
      messages.push(v.slice(0,120));
      if (messages.length > 30) messages.shift();
      renderWall();
      textInput.value = '';
    });

    // photo flow
    uploadPhotoBtn.addEventListener('click', ()=> fileInput.click());
    fileInput.addEventListener('change', async (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      // 簡單壓縮 (用於 demo，不做大量優化)
      const img = await loadImageFromFile(f);
      images.push({ img, w: img.width, h: img.height });
      if (images.length > 8) images.shift();
      renderWall();
      // reset input
      fileInput.value = '';
    });

    function loadImageFromFile(file){
      return new Promise((res, rej)=>{
        const fr = new FileReader();
        fr.onload = ()=> {
          const img = new Image();
          img.onload = ()=> res(img);
          img.onerror = rej;
          img.src = fr.result;
        };
        fr.readAsDataURL(file);
      });
    }

    // clear wall
    clearWallBtn.addEventListener('click', ()=>{
      messages.length = 0; images.length = 0; renderWall();
    });

    // ---------- Draw Canvas Implementation ----------
    const drawLayer = document.getElementById('drawLayer');
    const drawCanvas = document.getElementById('drawCanvas');
    const dctx = drawCanvas.getContext('2d');
    let drawing = false, lastX=0, lastY=0;
    const strokes = []; // undo stack of ImageData
    const maxUndo = 20;

    // resize draw canvas responsively
    function resizeDrawCanvas(){
      const w = Math.min(window.innerWidth - 48, 1000);
      const h = Math.min(window.innerHeight - 180, 800);
      drawCanvas.width = w; drawCanvas.height = h;
      // initial background
      dctx.fillStyle = '#fff'; dctx.fillRect(0,0,w,h);
    }
    window.addEventListener('resize', resizeDrawCanvas);
    resizeDrawCanvas();

    function pushState(){ 
      if (strokes.length >= maxUndo) strokes.shift();
      strokes.push(dctx.getImageData(0,0,drawCanvas.width, drawCanvas.height));
    }
    function undo(){
      if (!strokes.length) return;
      const im = strokes.pop();
      dctx.putImageData(im,0,0);
    }

    function startDraw(x,y){
      drawing = true; lastX = x; lastY = y;
      pushState();
    }
    function drawTo(x,y){
      if (!drawing) return;
      dctx.lineJoin = 'round'; dctx.lineCap = 'round';
      dctx.strokeStyle = '#000'; dctx.lineWidth = Math.max(4, drawCanvas.width / 150);
      dctx.beginPath(); dctx.moveTo(lastX,lastY); dctx.lineTo(x,y); dctx.stroke();
      lastX = x; lastY = y;
    }
    function endDraw(){
      drawing = false;
    }

    // pointer events
    drawCanvas.addEventListener('pointerdown', (e)=>{
      drawCanvas.setPointerCapture(e.pointerId);
      const rect = drawCanvas.getBoundingClientRect();
      startDraw(e.clientX - rect.left, e.clientY - rect.top);
    });
    drawCanvas.addEventListener('pointermove', (e)=>{
      if (!drawing) return;
      const rect = drawCanvas.getBoundingClientRect();
      drawTo(e.clientX - rect.left, e.clientY - rect.top);
    });
    drawCanvas.addEventListener('pointerup', (e)=>{
      drawCanvas.releasePointerCapture(e.pointerId);
      endDraw();
    });
    drawCanvas.addEventListener('pointerleave', ()=> endDraw());

    // draw controls
    document.getElementById('openDraw').addEventListener('click', ()=>{
      drawLayer.style.display = 'block';
      resizeDrawCanvas();
    });
    document.getElementById('drawClose').addEventListener('click', ()=>{
      drawLayer.style.display = 'none';
    });
    document.getElementById('drawClear').addEventListener('click', ()=>{
      dctx.fillStyle = '#fff'; dctx.fillRect(0,0,drawCanvas.width, drawCanvas.height);
      strokes.length = 0;
    });
    document.getElementById('drawUndo').addEventListener('click', ()=> undo());
    document.getElementById('drawSave').addEventListener('click', ()=>{
      // convert canvas to image and add to images[]
      const dataURL = drawCanvas.toDataURL('image/png');
      const img = new Image();
      img.onload = ()=>{
        images.push({ img, w: img.width, h: img.height });
        if (images.length > 8) images.shift();
        renderWall();
      };
      img.src = dataURL;
      drawLayer.style.display = 'none';
    });

    // ---------- utility / image layering done ----------
    // done. initial status message
    const topHint = document.getElementById('topHint');

    // handle window resize for renderer
    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
